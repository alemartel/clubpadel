# Plan 0031: Arquitectura multi-tenant segura

## Descripción

Implementar una arquitectura multi-tenant donde el tenant se detecta automáticamente a partir del host; el backend valida que el usuario pertenece a ese tenant; todas las queries a Neon estén aisladas por tenant; y nunca se permita acceso a datos de otro tenant. Todas las tablas de negocio deben incluir `tenant_id`. En cada request el backend debe validar: (1) que el usuario está autenticado, (2) que su `tenant_id` coincide con el tenant detectado por el subdominio.

---

## Fase 1: Capa de datos y tenant

### 1.1 Tabla `tenants`

- **Archivo nuevo:** `server/src/schema/tenants.ts` (o añadir en `users.ts` / schema existente).
- Definir tabla `app.tenants`: `id` (PK, text UUID), `host` (text, único; ej. `www.mypadelcenter.com`, `inplay.mypadelcenter.com`), `name` (text), `created_at`, `updated_at`.
- Alternativa: identificar por subdominio (ej. `inplay`) y derivar host; entonces columna `subdomain` o `host` según convención elegida. La resolución request → tenant debe ser por el valor de la cabecera `Host` del request.

### 1.2 Migración: añadir `tenant_id` a tablas de negocio

- **Archivos:** `server/src/schema/users.ts`, `server/src/schema/teams.ts`, `server/src/schema/leagues.ts`, `server/src/schema/events.ts`.
- **Tablas que deben incluir `tenant_id` (FK a `tenants.id`):**
  - **users** – `tenant_id` NOT NULL (tras migración).
  - **teams** – `tenant_id` NOT NULL.
  - **team_members** – no añadir `tenant_id`; el aislamiento se hace vía `teams.tenant_id`.
  - **team_availability** – idem, vía `teams`.
  - **team_change_notifications** – vía `team_id` o añadir `tenant_id` para consultas directas por tenant.
  - **team_leagues** – vía `teams`/`leagues`.
  - **league_payments** – vía `teams`/`leagues` o añadir `tenant_id`.
  - **leagues** – `tenant_id` NOT NULL.
  - **matches**, **bye_weeks** – vía `leagues`.
  - **events** – `tenant_id` NOT NULL.
  - **event_participants**, **event_teams**, **event_team_members**, **event_matches** – vía `events` o añadir `tenant_id` donde se hagan listados/filtros por tenant.
- Crear migración Drizzle en `server/drizzle/` que:
  1. Cree la tabla `tenants`.
  2. Añada `tenant_id` a las tablas indicadas.
  3. Inserte un tenant por defecto (ej. host `www.mypadelcenter.com`) y actualice todas las filas existentes con ese `tenant_id`.
  4. Ponga NOT NULL y FK a `tenants.id` donde corresponda.

### 1.3 Unicidad y constraints

- Revisar **todas** las restricciones UNIQUE actuales. Con multi-tenant, las unicidades deben ser por tenant donde aplique:
  - **users.email** – único por tenant: `unique(tenant_id, email)`.
  - **teams.name** – ya existe `teams_league_name_unique` y `teams_name_unique`; pasar a único por tenant (ej. `unique(tenant_id, name)`) y/o por league dentro del tenant.
  - **teams.passcode** – decidir si global único o por tenant; si por tenant: `unique(tenant_id, passcode)`.
  - **leagues** – nombres únicos por tenant.
  - **events** – nombres únicos por tenant si aplica.
- Ajustar FKs y referencias entre tablas tras añadir `tenant_id`.

---

## Fase 2: Detección de tenant y middleware en el backend

### 2.1 Resolver tenant desde el host

- **Archivo:** `server/src/lib/tenant.ts` (nuevo) o dentro de middleware.
- Función que reciba el `Host` del request (ej. `c.req.header("Host")` o `c.req.raw.headers.get("Host")`), normalice (quitar puerto si viene `host:port`) y consulte la tabla `tenants` por `host`. Devolver `tenant_id` o `null` si no hay tenant para ese host.
- Si el host no está registrado en `tenants`, el request a rutas protegidas/admin debe fallar (403/404) y nunca usar un tenant por defecto para no filtrar datos.

### 2.2 Middleware de tenant (antes o después de auth)

- **Archivos:** `server/src/middleware/auth.ts` y/o nuevo `server/src/middleware/tenant.ts`.
- Orden lógico: (1) Resolver tenant desde Host → (2) Auth (cargar user) → (3) Validar `user.tenant_id === request_tenant_id`.
- **Opciones de diseño:**
  - **Opción A – Middleware de tenant separado:** Primero middleware que resuelve tenant desde Host, pone `c.set("tenantId", tenantId)` y, si no hay tenant para el host, responde 403/404 y no llama a `next()`. Luego `authMiddleware` y, tras cargar el user, un middleware adicional (o lógica dentro de auth) que compruebe `user.tenant_id === c.get("tenantId")`; si no coincide, 403.
  - **Opción B – Integrado en auth:** Dentro de `authMiddleware`, después de obtener el user: leer Host, resolver tenant_id, comparar con `user.tenant_id`, y si no coinciden devolver 403. Guardar `c.set("tenantId", tenantId)` para los handlers.
- En ambos casos, **en cada request** a rutas protegidas/admin se debe validar: usuario autenticado y `user.tenant_id` coincide con el tenant del host. Nunca servir datos de otro tenant.

### 2.3 Rutas donde aplicar

- **Aplicar** detección de tenant y comprobación usuario–tenant en todas las rutas que usen `authMiddleware`: es decir, en `protectedRoutes` y `adminRoutes` (`server/src/api.ts`). Las rutas públicas (`/hello`, `/contact`, `/db-test`, etc.) no necesitan tenant; si se accede a BD en públicas (ej. `/db-test`), decidir si se filtra por un tenant por defecto o se deja sin tenant (solo para diagnóstico).
- **Montaje:** Asegurar que el middleware de tenant (o la lógica integrada en auth) se ejecute para todo lo montado bajo `/api/v1/protected` y `/api/v1/admin`.

### 2.4 Contexto Hono

- **Archivo:** Donde se declare `ContextVariableMap` (ej. en `middleware/auth.ts`), añadir `tenantId: string` (o el tipo del id de tenant) para que los handlers puedan usar `c.get("tenantId")` en todas las queries.

---

## Fase 3: Aislamiento de queries por tenant

### 3.1 Regla de oro

- **Nunca permitir acceso a datos de otro tenant.** En todos los SELECT/INSERT/UPDATE/DELETE que toquen tablas de negocio con `tenant_id`, el backend debe:
  - Incluir condición por `tenant_id` igual a `c.get("tenantId")`, o
  - Asegurar que los IDs usados (ej. `team_id`, `league_id`, `event_id`) pertenecen al tenant actual comprobando la fila padre (team/league/event) tiene ese `tenant_id` antes de continuar.

### 3.2 Archivos a tocar

- **server/src/api.ts** – Todas las rutas que lean o escriban: `users`, `teams`, `team_members`, `team_availability`, `team_change_notifications`, `team_leagues`, `league_payments`, `leagues`, `matches`, `bye_weeks`, `events`, `event_participants`, `event_teams`, `event_team_members`, `event_matches`.
- **Patrón:** Para listados (GET que devuelven colecciones), filtrar siempre por `tenant_id` del contexto. Para operaciones por ID (GET/PUT/DELETE por `:id`), después de cargar la fila, comprobar que `row.tenant_id === c.get("tenantId")`; si no, 404. Para INSERT, asignar siempre `tenant_id: c.get("tenantId")`.

### 3.3 Helpers opcionales

- **Archivo:** `server/src/lib/db-helpers.ts` o similar. Funciones tipo `withTenant(db, tenantId)` que devuelvan un “scope” o wrappers que inyecten `tenant_id` en los `.where()` para no repetir lógica. Opcional; se puede hacer solo con `c.get("tenantId")` en cada handler.

### 3.4 Passcodes y emails

- **teams.passcode:** Si se mantiene único global, no cambiar. Si se pasa a único por tenant, actualizar generación de passcode y constraint como en 1.3.
- **users.email:** Login y registro deben usar `tenant_id` del host: al crear usuario o al buscarlo por email, scope por tenant; así el mismo email puede existir en distintos tenants.

---

## Fase 4: Auth y registro asociados al tenant

### 4.1 Primer acceso (login) y registro

- **Archivo:** `server/src/middleware/auth.ts`.
- Cuando se crea un usuario nuevo (insert en `users`), asignar `tenant_id` al tenant resuelto del Host del request. Si en ese momento no hay tenant (host no registrado), no crear usuario y devolver 403.
- Para login: el usuario ya tiene `tenant_id`; la validación “user.tenant_id === tenant del host” asegura que solo puede usar el subdominio/host de su tenant.

### 4.2 Admin

- **Archivo:** `server/src/middleware/admin.ts`.
- El admin es por tenant: un usuario con `role === 'admin'` solo es admin dentro de su `tenant_id`. El middleware admin debe ejecutarse después de auth y tenant; comprobar `user.role === 'admin'` y, implícitamente, que el tenant ya fue validado (mismo user). No exponer datos de otros tenants.

---

## Resumen de archivos implicados

| Área | Archivos |
|------|----------|
| Schema | `server/src/schema/tenants.ts` (nuevo), `users.ts`, `teams.ts`, `leagues.ts`, `events.ts` |
| Migraciones | `server/drizzle/XXXX_multi_tenant.sql` (y actualizar journal/snapshots si aplica) |
| Tenant + Auth | `server/src/lib/tenant.ts` (nuevo), `server/src/middleware/auth.ts`, opcional `middleware/tenant.ts` |
| API | `server/src/api.ts` (todas las rutas protegidas/admin que acceden a BD) |
| Admin | `server/src/middleware/admin.ts` |

---

## Orden recomendado de implementación

1. **Fase 1:** Schema `tenants`, añadir `tenant_id` a tablas, migración con tenant por defecto y actualización de datos existentes. Ajustar uniques.
2. **Fase 2:** Resolución de tenant por Host, middleware que valida usuario autenticado y `user.tenant_id === tenant` del host; exponer `tenantId` en contexto.
3. **Fase 3:** Recorrer cada endpoint en `api.ts` y aplicar filtro/check por `tenant_id` en todas las queries de negocio.
4. **Fase 4:** Ajustar creación de usuario (y registro si existe en backend) para asignar `tenant_id` desde el host; revisar admin para que sea por tenant.

---

## Notas de seguridad

- No confiar en ningún header que el cliente pueda falsificar para elegir tenant; **solo** el `Host` (que en producción viene del request entrante al servidor) debe determinar el tenant. En desarrollo, el cliente puede enviar Host distinto; en producción, el reverse proxy (Vercel, etc.) debe pasar el Host real.
- Defensa en profundidad: además del middleware, **todas** las queries que devuelven o modifican datos de negocio deben filtrar o comprobar `tenant_id`. Opcionalmente, en Neon/Postgres se puede usar RLS (row-level security) con `current_setting('app.tenant_id')` para un segundo nivel de aislamiento.
